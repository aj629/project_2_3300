<!DOCTYPE html>
<html>

<head>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <title> Project 2 for INFO 3300 </title>
  <meta charset="UTF-8">
  <style>
    .state {
      fill: lightgrey;
    }

    .border {
      stroke: black;
      stroke-width: 1px;
      fill: none;
    }
  </style>
</head>

<body>

  <svg id="usmap" height="800" width="900"></svg>
  <script>
    const svg = d3.select("#usmap");
    const width = svg.attr("width");
    const height = svg.attr("height");
    const margin = { top: 10, right: 10, bottom: 10, left: 10 };
    const mapWidth = width - margin.left - margin.right;
    const mapHeight = height - margin.top - margin.bottom;
    const map = svg.append("g")
      .attr("transform", `translate(${margin.left}, ${margin.top})`);





    const requestData = async function () {
      const fortuneData = await d3.csv('./data/Fortune_1000.csv');
      console.log(fortuneData);
      const costOfLiving = await d3.csv('./data/cost-of-living-2018.csv');
      console.log(costOfLiving);

      // filtered the data by only returning the companies where the sector is listed as Technology
      const filteredFD = fortuneData.filter((d) => { return d.sector === "Technology"; })
      console.log(filteredFD);

      const levelsFyi = await d3.csv('./data/Levels_Fyi_Salary_Data.csv');
      console.log(levelsFyi);


      const usMap = await d3.json("./data/us.json");
      console.log(usMap);

      const cities = await d3.json("./data/cities.json");


      // state object stuff
      var states = topojson.feature(usMap, usMap.objects.states);
      var statesMesh = topojson.mesh(usMap, usMap.objects.states);
      var projection = d3.geoAlbersUsa().fitSize([mapWidth, mapHeight], states);
      var path = d3.geoPath().projection(projection);
      let viewport = map.append("g");

      viewport.selectAll(".state").data(states.features)
        .enter()
        .append("path")
        .attr("class", "state")
        .attr("d", path);

      viewport.append("path")
        .datum(statesMesh)
        .attr("class", "border")
        .attr("d", path);



      // // shade in the states
      // map.selectAll("path").data(states.features)
      //   .join("path")
      //   .attr("class", "state")
      //   .attr("note", d => d.id)
      //   .attr("d", path);


      // // draw the borders
      // map.append("path").datum(statesMesh)
      //   .attr("class", "border")
      //   .attr("d", path);

      // changing fortune 1000 dataset to become a map with key: company name and value: all other attributes
      var fortune = d3.index(filteredFD, d => d.company);
      console.log(fortune);

      // filtering levelsFyi dataset to only contain companies that are in the fortune 1000 dataset and have the same city name
      // this results in duplicates in the dataset -- entries will have the same company name and be in the same city, but each entry will be a different salary
      let levelsFyiFiltered = levelsFyi.filter(function (d, i) {
        d.citySplit = d.location.split(",");
        let fortunekey = d.company;
        let companyKey = fortune.get(fortunekey);
        return ((fortune.has(fortunekey)) && (d.citySplit[0] === companyKey.city))
      });
      console.log(levelsFyiFiltered);

      // getting unique cities from levelsFyi data 
      let duplicateCities = [];
      fortune.forEach(d => {
        duplicateCities.push(d.city);
      })

      let uniqueCities = duplicateCities.filter((city, i, ar) => ar.indexOf(city) === i);
      console.log(duplicateCities);
      console.log(uniqueCities);


      // make the cities data a map with key: city, value: lat/long
      var filteredCities = cities.filter(function (d) {
        return uniqueCities.includes(d.city);
      })
      console.log(filteredCities); // not all cities in the company dataset are included in the lat/long dataset


      // get the latitude and longitutde positions for the city locations of companies
      filteredCities.forEach(d => {
        d.Position = projection([d.longitude, d.latitude]);
        console.log(d.Position);
      })

      // plot the cities with longitude and latitude
      viewport.selectAll("circle.company")
        .data(filteredCities)
        .join("circle")
        .attr("class", "company")
        .attr('cx', d => d.Position[0])
        .attr('cy', d => d.Position[1])
        .style("fill", 'black')
        .attr('r', 5);



      var zoom = d3.zoom()
        .scaleExtent([1, 10])
        .on("zoom", mapZoomed);

      map.call(zoom);

      map.call(zoom.transform, d3.zoomIdentity);


      viewport.selectAll(".state").on("click", clicked);



      function mapZoomed({ transform }) {


        viewport.attr("transform", transform.toString());

        viewport.select(".border")
          .style("stroke-width", 2 / transform.k);

        viewport.selectAll("circle.company")
          .attr('r', transform.k>=2 ? 6/transform.k : 4);

        console.log( viewport.selectAll("circle.company").attr('r'));





      }





      function clicked(event, d) {

        console.log(d);

        let bounds = path.bounds(d.geometry);
        console.log(bounds);
        let dx = bounds[1][0] - bounds[0][0];
        let dy = bounds[1][1] - bounds[0][1];
        let x = (bounds[0][0] + bounds[1][0]) / 2;
        let y = (bounds[0][1] + bounds[1][1]) / 2;

        let scale = Math.max(1, Math.min(10, 0.9 / Math.max(dx / mapWidth,
          dy / mapHeight)));
        let translate = [mapWidth / 2 - x * scale, mapHeight / 2 - y * scale];

        let newTransform = d3.zoomIdentity
          .translate(translate[0], translate[1])
          .scale(scale);

        // viewport.selectAll("circle.company")
        //   .attr('r', 1);

        map.transition().duration(1000).call(zoom.transform, newTransform);

      }




    }





    requestData();


  </script>
</body>

</html>