<!DOCTYPE html>
<html>

<head>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <title> Project 2 for INFO 3300 </title>
  <meta charset="UTF-8">
  <style>
    .state {
      fill: lightgrey;
    }

    .border {
      stroke: black;
      stroke-width: 1px;
      fill: none;
    }
  </style>
</head>

<body>

  <svg id="usmap" height="800" width="900"></svg>
  <script>
    const svg = d3.select("#usmap");
    const width = svg.attr("width");
    const height = svg.attr("height");
    const margin = { top: 10, right: 10, bottom: 10, left: 10 };
    const mapWidth = width - margin.left - margin.right;
    const mapHeight = height - margin.top - margin.bottom;
    const map = svg.append("g")
      .attr("transform", `translate(${margin.left}, ${margin.top})`);





    const requestData = async function () {
      const fortuneData = await d3.csv('./data/Fortune_1000.csv');
      console.log(fortuneData);
      const costOfLiving = await d3.csv('./data/cost-of-living-2018.csv');
      console.log(costOfLiving);

      // filtered the data by only returning the companies where the sector is listed as Technology
      const filteredFD = fortuneData.filter((d) => { return d.sector === "Technology"; })
      console.log(filteredFD);

      const levelsFyi = await d3.csv('./data/Levels_Fyi_Salary_Data.csv');
      console.log(levelsFyi);


      const usMap = await d3.json("./data/us.json");
      console.log(usMap);

      const cities = await d3.json("./data/cities.json");


      // state object stuff
      var states = topojson.feature(usMap, usMap.objects.states);
      var statesMesh = topojson.mesh(usMap, usMap.objects.states);
      var projection = d3.geoAlbersUsa().fitSize([mapWidth, mapHeight], states);
      var path = d3.geoPath().projection(projection);
      let viewport = map.append("g");

      viewport.selectAll(".state").data(states.features)
        .enter()
        .append("path")
        .attr("class", "state")
        .attr("d", path);

      viewport.append("path")
        .datum(statesMesh)
        .attr("class", "border")
        .attr("d", path);



      // changing fortune 1000 dataset tox become a map with key: company name and value: all other attributes
      var fortune = d3.index(filteredFD, d => d.company);
      console.log(fortune);

      // filtering levelsFyi dataset to only contain companies that are in the fortune 1000 dataset and have the same city name
      // this results in duplicates in the dataset -- entries will have the same company name and be in the same city, but each entry will be a different salary
      let levelsFyiFiltered = levelsFyi.filter(function (d, i) {
        d.citySplit = d.location.split(",");
        let fortunekey = d.company;
        let companyKey = fortune.get(fortunekey);
        return ((fortune.has(fortunekey)) && (d.citySplit[0] === companyKey.city))
      });
      console.log(levelsFyiFiltered);

      // getting unique cities from levelsFyi data 
      let duplicateCities = [];
      fortune.forEach(d => {
        duplicateCities.push(d.city);
      })

      let uniqueCities = duplicateCities.filter((city, i, ar) => ar.indexOf(city) === i);
      console.log(duplicateCities);
      console.log(uniqueCities);


      // make the cities data a map with key: city, value: lat/long
      var filteredCities = cities.filter(function (d) {
        return uniqueCities.includes(d.city);
      })
      console.log(filteredCities); // not all cities in the company dataset are included in the lat/long dataset


      // get the latitude and longitude positions for the city locations of companies
      filteredCities.forEach(d => {
        d.Position = projection([d.longitude, d.latitude]);
        // console.log(d.Position);
      })

      // changing city name format to just the name of the city
      costOfLiving.forEach((d, i) => {
        d['City'] = d['City'].substring(0, d['City'].indexOf(','));
      })

      // making totalyearly compensation and salary ints 
      levelsFyiFiltered.forEach((d, i) => {
        d['basesalary'] = parseInt(d['basesalary']);
        d['totalyearlycompensation'] = parseInt(d['totalyearlycompensation']);
      })

      // Created cost of living index column for that city 
      filteredCities.forEach((d, i) => {
        costOfLiving.forEach((b, i) => {
          if (b['City'] === d['city']) {
            d['COL'] = b['Cost of Living Index'];
          }
        })
      })

      // Average total yearly compensation for each company 
      let avgSalaries = [];
      let counts = {};
      let companiesAndSalary = {};
      levelsFyiFiltered.forEach((b, i) => {
        let tempCompany = b['company'];
        if (!counts[tempCompany]) {
          counts[tempCompany] = 0;
          avgSalaries[tempCompany] = 0;
        }
        counts[tempCompany] = counts[tempCompany] + 1;
        avgSalaries[tempCompany] = avgSalaries[tempCompany] + b['totalyearlycompensation'];

      });
      Object.keys(avgSalaries).map(function (key, index) {
        avgSalaries[key] = Math.round(avgSalaries[key] / counts[key]);
      })
      // created companies column that contains array of all companies located in that city
      var companies = {};
      filteredCities.forEach((b, i) => {
        levelsFyiFiltered.forEach((d, i) => {
          let temp = d['citySplit'];
          if ((temp[0] === b.city) && !(b.city in companies)) {
            companies[d['company']] = avgSalaries[d['company']]
          }
        });
        b.companies = companies;
        companies = {};

      })
      console.log(filteredCities);




      // // plot the cities with longitude and latitude and add companies to them
      var circles = viewport.selectAll("circle.company")
        .data(filteredCities)
        .join("circle")
        .attr("class", "company")
        .attr('cx', d => d.Position[0])
        .attr('cy', d => d.Position[1])
        .style("fill", 'black')
        .attr('r', 5)
        .attr('company', 'hello');



      var zoom = d3.zoom()
        .scaleExtent([1, 10])
        .on("zoom", mapZoomed);

      map.call(zoom);

      map.call(zoom.transform, d3.zoomIdentity);


      viewport.selectAll(".state").on("click", clicked);



      function mapZoomed({ transform }) {


        viewport.attr("transform", transform.toString());

        viewport.select(".border")
          .style("stroke-width", 2 / transform.k);

        viewport.selectAll("circle.company")
          .attr('r', transform.k >= 2 ? 6 / transform.k : 4);
      }



      function clicked(event, d) {

        console.log(d);

        let bounds = path.bounds(d.geometry);
        console.log(bounds);
        let dx = bounds[1][0] - bounds[0][0];
        let dy = bounds[1][1] - bounds[0][1];
        let x = (bounds[0][0] + bounds[1][0]) / 2;
        let y = (bounds[0][1] + bounds[1][1]) / 2;

        let scale = Math.max(1, Math.min(10, 0.9 / Math.max(dx / mapWidth,
          dy / mapHeight)));
        let translate = [mapWidth / 2 - x * scale, mapHeight / 2 - y * scale];

        let newTransform = d3.zoomIdentity
          .translate(translate[0], translate[1])
          .scale(scale);

        map.transition().duration(1000).call(zoom.transform, newTransform);

      }


      let companytest=levelsFyiFiltered.filter((d) => { return d.company === "Apple"; })

      console.log(companytest)


    
      // let tooltipWidth = 120;
      // let tooltipHeight = 40;

      // let tooltip = viewport.attr("class", "tooltip")
      //   .attr("visibility", "hidden");
      // tooltip.append("rect")
      //   .attr("fill", "black")
      //   .attr("opacity", 0.9)
      //   .attr("x", -tooltipWidth / 2.0)
      //   .attr("y", 0)
      //   .attr("width", tooltipWidth)
      //   .attr("height", tooltipHeight)
      // let txt = tooltip.append("text")
      //   .attr("fill", "white")
      //   .attr("text-anchor", "middle")
      //   .attr("alignment-baseline", "hanging")
      //   .attr("x", 0)
      //   .attr("y", 2);
      // let txt2 = tooltip.append("text")
      //   .attr("fill", "white")
      //   .attr("text-anchor", "middle")
      //   .attr("alignment-baseline", "hanging")
      //   .attr("x", 0)
      //   .attr("y", 22);


      circles.on("click", mouseClicked);
      function mouseClicked() {
        // tooltip.style("visibility", "visible");
        let company = d3.select(this);
        console.log(this);
        // find city for company
        // find salary for company from levels.fyi 
        // find cost of living 
      }

    }





    requestData();


  </script>
</body>

</html>