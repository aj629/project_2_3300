<html>

<head>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <title>Project 2 for INFO 3300</title>
  <meta charset="UTF-8" />
  <style>
    .state {
      fill: lightgrey;
    }

    .border {
      stroke: black;
      stroke-width: 1px;
      fill: none;
    }

    .labelThing {
      stroke: black;
      stroke-width: 2px;
    }

    #legend {
      margin-left: 250;
    }
    #titlediv {
      margin-bottom: 20px;
    }
    p {
      font-family: avenir;
      font-size: 18;
      font-style: italic;
      fill: black;
    
    }

    .container {
      width: 800px;
      margin-left: 50px;
      margin-bottom: 20px;

    }

    
  </style>
</head>

<body>
  <div id='titlediv'>
    <svg id = "titlesvg" width = "900" height= "100"></svg>
  </div>
  <div class="container">
    <p>The dots on the map below show cities that have Fortune 1000 Tech companies in the United States. Click anywhere on the map to zoom in closer to a state. 
      Click on the "Zoom Out" button in the bottom left to zoom out completely.</p>
  </div>
  <svg id="usmap" height="800" width="900"></svg>
  <div id="buttoncont"></div>
  <div id="legend">
    <svg id = "legendsvg" height = "100" width = "600">

    </svg>
  </div>
  <script>
    const svg = d3.select("#usmap");
    const width = svg.attr("width");
    const height = svg.attr("height");
    const margin = { top: 10, right: 10, bottom: 10, left: 10 };
    const mapWidth = width - margin.left - margin.right;
    const mapHeight = height - margin.top - margin.bottom;
    const map = svg
      .append("g")
      .attr("transform", `translate(${margin.left}, ${margin.top})`);



    const requestData = async function () {

      d3.select("#buttoncont").append("button")
        .text("Zoom Out")
        .style('font-family', 'avenir')
        .on("click", zoomOut);
      const fortuneData = await d3.csv("./data/Fortune_1000.csv");
      // console.log(fortuneData);
      const costOfLiving = await d3.csv("./data/cost-of-living-2018.csv");
      // console.log(costOfLiving);
      const stateName = await d3.tsv("./data/us-state-names.tsv");
      // console.log(stateName);

      // filtered the data by only returning the companies where the sector is listed as Technology
      const filteredFD = fortuneData.filter((d) => {
        return d.sector === "Technology";
      });

      // const filteredFD = fortuneData;
      // console.log(filteredFD);

      const levelsFyi = await d3.csv("./data/Levels_Fyi_Salary_Data.csv");
      // console.log(levelsFyi);

      const usMap = await d3.json("./data/us.json");
      // console.log(usMap);

      const cities = await d3.json("./data/cities.json");

      // state object stuff
      var states = topojson.feature(usMap, usMap.objects.states);
      // console.log(states);

      // console.log(stateName[0]);
      states.features.forEach((d, i) => {

        // console.log(d.id);
        // console.log(stateName[d.id]);

        d["abbrv"] = stateName[i].code;
      });

      // console.log(states);
      var statesMesh = topojson.mesh(usMap, usMap.objects.states);
      var projection = d3
        .geoAlbersUsa()
        .fitSize([mapWidth, mapHeight], states);
      var path = d3.geoPath().projection(projection);
      let viewport = map.append("g");

      viewport
        .selectAll(".state")
        .data(states.features)
        .enter()
        .append("path")
        .attr("class", "state")
        .attr("d", path);

      viewport
        .append("path")
        .datum(statesMesh)
        .attr("class", "border")
        .attr("d", path);

      // changing fortune 1000 dataset tox become a map with key: company name and value: all other attributes
      var fortune = d3.index(filteredFD, (d) => d.company);
      // console.log(fortune);

      // filtering levelsFyi dataset to only contain companies that are in the fortune 1000 dataset and have the same city name
      // this results in duplicates in the dataset -- entries will have the same company name and be in the same city, but each entry will be a different salary
      let levelsFyiFiltered = levelsFyi.filter(function (d, i) {
        d.citySplit = d.location.split(",");
        let fortunekey = d.company;
        let companyKey = fortune.get(fortunekey);
        return fortune.has(fortunekey) && d.citySplit[0] === companyKey.city;
      });
      console.log(levelsFyiFiltered);


      // getting unique cities from levelsFyi data
      let duplicateCities = [];
      fortune.forEach((d) => {
        duplicateCities.push(d.city);
      });

      let uniqueCities = duplicateCities.filter(
        (city, i, ar) => ar.indexOf(city) === i
      );
      // console.log(duplicateCities);
      // console.log(uniqueCities);

      // make the cities data a map with key: city, value: lat/long
      var filteredCities = cities.filter(function (d) {
        return uniqueCities.includes(d.city);
      })
      console.log(filteredCities); // not all cities in the company dataset are included in the lat/long dataset


      // adding cities that don't have longitude and latitude
      let allCities = [];
      filteredCities.forEach((d, i) => {
        allCities.push(d.city);
      })
      console.log(allCities);

      var missingCities = [];
      uniqueCities.forEach((d, i) => {
        if (!allCities.includes(d)) {
          missingCities.push(d);
        }
      })
      console.log(missingCities);

      let citiesToAdd = [{
        "city": "Armonk",
        "latitude": 41.1264849,
        "longitude": -73.7140195,
        "state": "New York"
      },

      {
        "city": "Menlo Park",
        "latitude": 37.452961,
        "longitude": -122.181725,
        "state": "California"
      },

      {
        "city": "Boise",
        "latitude": 43.618881,
        "longitude": -116.215019
      }

      ]
      // hard coding additional latitude and longitude that is missing from the dataset
      citiesToAdd.forEach(d => {
        filteredCities.push(d);
      })
      console.log(filteredCities);


      // get the latitude and longitutde positions for the city locations of companies
      filteredCities.forEach(d => {
        d.Position = projection([d.longitude, d.latitude]);
        // console.log(d.Position);
      });

      // changing city name format to just the name of the city
      costOfLiving.forEach((d, i) => {
        d["City"] = d["City"].substring(0, d["City"].indexOf(","));
      });

      // making totalyearly compensation and salary ints
      levelsFyiFiltered.forEach((d, i) => {
        d["basesalary"] = parseInt(d["basesalary"]);
        d["totalyearlycompensation"] = parseInt(d["totalyearlycompensation"]);
      });

      // Created cost of living index column for that city
      filteredCities.forEach((d, i) => {
        costOfLiving.forEach((b, i) => {
          if (b["City"] === d["city"]) {
            d["COL"] = b["Cost of Living Index"];
          }
        });
      });

      // Average total yearly compensation for each company
      let avgSalaries = [];
      let counts = {};
      let companiesAndSalary = {};
      levelsFyiFiltered.forEach((b, i) => {
        let tempCompany = b["company"];
        if (!counts[tempCompany]) {
          counts[tempCompany] = 0;
          avgSalaries[tempCompany] = 0;
        }
        counts[tempCompany] = counts[tempCompany] + 1;
        avgSalaries[tempCompany] =
          avgSalaries[tempCompany] + b["totalyearlycompensation"];
      });
      Object.keys(avgSalaries).map(function (key, index) {
        avgSalaries[key] = Math.round(avgSalaries[key] / counts[key]);
      });
      // created companies column that contains array of all companies located in that city
      var companies = {};
      filteredCities.forEach((b, i) => {
        levelsFyiFiltered.forEach((d, i) => {
          let temp = d["citySplit"];
          if (temp[0] === b.city && !(b.city in companies)) {
            companies[d["company"]] = avgSalaries[d["company"]];
          }
        });
        b.companies = companies;
        companies = {};
      });

      // filtered out cities without companies
      var filteredNewCities = filteredCities.filter(function (d) {
        return Object.keys(d.companies).length !== 0;
      });
      console.log(filteredNewCities);


      // var citiesMapped = [];
      // filteredNewCities.forEach( function(d) {
      //   Object.keys(d.companies).forEach( b => citiesMapped.push(b));

      // });
      // console.log(citiesMapped);
      // console.log(levelsFyiFiltered);
      // let levelsFyiFilteredStates = levelsFyiFiltered.filter( function(d) {
      //   console.log(d.company);
      //   return (citiesMapped.includes(d.company))
      // })
      // console.log(levelsFyiFilteredStates);

      // coloring the states by the number of companies in each state
      var salary_dict = {};
      levelsFyiFiltered.forEach((b, i) => {
        if (b.company in salary_dict) {
          salary_dict[b.company]["salary"].push(b.totalyearlycompensation);
        } else {
          salary_dict[b.company] = {
            state: b.citySplit[1].slice(1, 3),
            salary: [b.totalyearlycompensation],
          };
        }
      });
      // console.log(salary_dict);

      var state_dict = {};
      var company_total = 0;

      for ([key, val] of Object.entries(salary_dict)) {
        if (val.state in state_dict) {
          state_dict[val.state]++;
          company_total++;
        } else {
          state_dict[val.state] = 1;
          company_total++;
        }
      }

      stateName.forEach((d, i) => {
        if (!(d.code in state_dict)) {
          state_dict[d.code] = 0
        }
      })
      state_dict['VA'] = 0;
      console.log(state_dict)
      // console.log(salary_dict);
      // console.log(state_dict);

      // we hard coded extent to make the range of colors smoother and more informative
      // const minMax = d3.extent(Object.values(state_dict));
      // console.log(minMax);
      console.log(Object.values(state_dict).sort((a, b) => a - b));

      // changed color scale
      // credit: https://colorbrewer2.org/#type=sequential&scheme=YlGnBu&n=5
      const colorScale = d3.scaleOrdinal(Object.values(state_dict).sort((a, b) => a - b), ["lightgrey", "#ffffcc", "#a1dab4", "#41b6c4", "#2c7fb8", "#253494"]);

      // code if we want to use fortune data not filtered by tech
      // changed color scale
      // credit: https://colorbrewer2.org/#type=sequential&scheme=YlGnBu&n=5
      //const colorScale = d3.scaleOrdinal(Object.values(state_dict).sort((a,b) => a-b), ["lightgrey", "#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"]);
      let uniqueNumbers = (Object.values(state_dict).sort((a,b) => a-b)).filter(
        (value, i, ar) => ar.indexOf(value) === i
      );

      console.log(uniqueNumbers);

      // add a conditional so that if state is not in state dict, color it gray
      map
        .selectAll(".state")
        .style("fill", (d) => colorScale(state_dict[d.abbrv]));
      // console.log(state_dict);

      // draw a legend

      let legend = d3.select('svg#legendsvg');
      // Add one dot in the legend for each name.
      legend.append("text")
            .text('Legend: Number of companies in each state')
            .attr('x', 70)
            .attr('y', 25)
            .style('font-family', 'avenir')
            .style('font-size', 15);

      legend.selectAll("rect.legendsquare")
        .data(uniqueNumbers)
        .join("rect")
          .attr('class', 'legendsquare')
          .attr("x", function(d,i){ {return 10 + i*70}})
          .attr("y", 50) 
          .attr("rx", 7)
          .attr("ry", 7)
          .attr("width", 20)
          .attr("height", 20)
          .style("fill", function(d){ return colorScale(d)})

      //Add one dot in the legend for each name.
      legend.selectAll("labels")
        .data(uniqueNumbers)
        .join("text")
        .attr("x", function(d,i){ return 40 + i*70})
        .attr("y", 60) 
        .style("fill", "black")
        .text(function(d){ return d})
        .attr("text-anchor", "left")
        .style('font-family', 'avenir')
        .style("alignment-baseline", "middle")



      // // plot the cities with longitude and latitude and add companies to them
      var circles = viewport
        .selectAll("circle.company")
        .data(filteredNewCities)
        .join("circle")
        .attr("class", "company")
        .attr("cx", (d) => d.Position[0])
        .attr("cy", (d) => d.Position[1])
        .style("fill", "black")
        .style("stroke", "pink")
        .attr("r", 5);

      // var cityLabel = viewport.selectAll("text.cityname").data(filteredCities).join("text").style("font-size", "12px" ).text(d => d.city).attr('x', d => d.Position[0] + 5)
      //   .attr('y', d => d.Position[1] + 5).attr("class", "cityname");

      let stateClick = viewport.selectAll(".state");

      var zoom = d3.zoom().scaleExtent([1, 10]).on("zoom", mapZoomed);


      let tooltipWidth = 200;
      let tooltipHeight = 150;
      let tooltip = svg
        .append("g")
        .attr("class", "tooltip")
        .attr("visibility", "hidden");

      var circle;

      tooltip
        .append("rect")
        .attr("class", "labelThing")
        .attr("fill", "white")
        .attr("width", tooltipWidth)
        .attr("height", tooltipHeight)
        .attr("x", 0)
        .attr("y", 0);
      let txt = tooltip
        .append("text")
        .attr("class", "tooltipText")
        .attr("fill", "black")
        .attr("text-anchor", "start")
        .attr("alignment-baseline", "hanging")
        .attr("x", 0)
        .attr("y", 0);
      let txt2 = tooltip
        .append("text")
        .attr("class", "tooltipText")
        .attr("fill", "black")
        .attr("text-anchor", "start")
        .attr("alignment-baseline", "hanging")
        .attr("x", 0)
        .attr("y", 0);

      let txt3 = tooltip
        .append("text")
        .attr("class", "tooltipText")
        .attr("fill", "black")
        .attr("text-anchor", "start")
        .attr("alignment-baseline", "hanging")
        .attr("x", 0)
        .attr("y", 0);

      function mapZoomed({ transform }) {
        viewport.attr("transform", transform.toString());

        viewport.select(".border").style("stroke-width", 2 / transform.k);

        viewport
          .selectAll("circle.company")
          .attr("r", transform.k >= 2 ? 6 / transform.k : 4)
          .style("stroke-width", transform.k >= 1 ? 2 / transform.k : 0.5);

        circles.on("mouseover", function () {

          let circle = d3.select(this).datum()


          viewport.append("text").attr("class", "city").text(circle.city).style("font-size", `${20/transform.k}`).attr("x", circle.Position[0] + 2).attr("y", circle.Position[1] + 2)


        });


        circles.on("mouseout", function () {



          d3.select(".city").remove();


        });


        // var x_loc = d3.select(".labelThing").attr("x")

        // var y_loc = d3.select(".labelThing").attr("y")



        // d3.select(".labelThing").attr("x", transform.k > 1 ? (x_loc - transform.x) / transform.k : 0)
        //   .attr("y", transform.k > 1 ? (y_loc - transform.y) / transform.k : 0);

        // d3.select(".tooltipText").attr("x", transform.k > 1 ? (x_loc - transform.x) / transform.k : 0)
        //   .attr("y", transform.k > 1 ? (y_loc - transform.y) / transform.k : 0);








        // viewport.selectAll("text.cityname").data(filteredNewCities).join("text").style("font-size", (transform.k > 3) ? "1px" : "0px").text(d => d.city).attr('x', d => (Number(d.rank)%2===0) ? d.Position[0] - 3 : d.Position[0] + 3)
        //   .attr('y', d => d.Position[1]-1).attr("class", "cityname");
      }

      map.call(zoom);
      map.call(zoom.transform, d3.zoomIdentity);

      // console.log(filteredCities)

      function clicked(event, d) {
        // console.log(d);

        let bounds = path.bounds(d.geometry);
        console.log(bounds);
        let dx = bounds[1][0] - bounds[0][0];
        let dy = bounds[1][1] - bounds[0][1];
        let x = (bounds[0][0] + bounds[1][0]) / 2;
        let y = (bounds[0][1] + bounds[1][1]) / 2;
        circles.style("fill", "black");
        tooltip.style("visibility", "hidden");

        let scale = Math.max(
          1,
          Math.min(10, 0.9 / Math.max(dx / mapWidth, dy / mapHeight))
        );
        let translate = [mapWidth / 2 - x * scale, mapHeight / 2 - y * scale];

        let newTransform = d3.zoomIdentity
          .translate(translate[0], translate[1])
          .scale(scale);

        map.transition().duration(1000).call(zoom.transform, newTransform);
      }

      viewport.selectAll(".state").on("click", clicked);











      function zoomOut() {

        map.transition().duration(1000).call(zoom.transform, d3.zoomIdentity);
      };

      circles.on("click", function () {

        tooltip.style("visibility", "visible");

        circles.style("fill", "black");

        d3.select(this).style("fill", "white");

        circle = d3.select(this).datum();
        // salaries and companies
        console.log(circle);
        let circleCompanies = circle.companies;
        // find city for company
        let circleCities = circle.city;
        console.log(circleCities);
        // find cost of living
        let circleCoL = circle.COL;
        //console.log(circleCoL);
        console.log(circleCompanies);

        // txt.text(JSON.stringify(circleCompanies));
        // txt2.text(circleCoL);

        d3.select(".labelThing").attr("x", circle.Position[0] + 5)
          .attr("y", circle.Position[1] + 10)


        var company_and_salary = JSON.stringify(circleCompanies);
        var company_name = company_and_salary.substr(2, company_and_salary.indexOf(':') - 3);
        // console.log(company_name);
        var average_sal = company_and_salary.substr(company_and_salary.indexOf(':') + 1, company_and_salary.indexOf('}') - 1);
        console.log(average_sal);
        txt.text("Company: " + company_name).attr("x", circle.Position[0] + 10)
          .attr("y", circle.Position[1] + 30);
        txt2.text("Average Salary: $" + average_sal.substr(0, average_sal.length - 1)).attr("x", circle.Position[0] + 10)
          .attr("y", circle.Position[1] + 50);;
        txt3.text("City: " + circleCities).attr("x", circle.Position[0] + 10)
          .attr("y", circle.Position[1] + 70);;


      });


      // console.log(states);


      // adding a title
      let title = d3.select("svg#titlesvg");
      title.append('rect')
           .style('fill', "#253494")
           .attr('x',0)
           .attr('y', 0)
           .attr('height', 100)
           .attr('width', 900);

      title.append('text')
          .text('Map of Salaries of Fortune 1000 Tech Companies in the United States')
          .attr('x', 60)
          .attr('y', 50)
          .attr('fill', 'white')
          .attr('font-size', 25)
          .style('font-family', 'avenir');

      // title.append('text')
      //      .text('The dots on the map below show cities that have Fortune 1000 Tech companies in the United States. Click anywhere on the map to zoom in closer to a state. Click on the "Zoom Out" button in the bottom left to zoom out completely.')
      //      .style('font-family', 'avenir')
      //      .attr('x', 10)
      //      .attr('y', 150)
      //      .style('font-size', 18)
      //      .style('font-style', 'italic')
      //      .attr('fill', 'black');
      

    };

    requestData();
  </script>



</body>

</html>