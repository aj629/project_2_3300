<!DOCTYPE html>
<html>

<head>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <title> Project 2 for INFO 3300 </title>
  <meta charset="UTF-8">
  <style>
    .state {
      fill: lightgrey;
    }

    .border {
      stroke: black;
      stroke-width: 1px;
      fill: none;
    }
  </style>
</head>

<body>

  <svg id="usmap" height="800" width="900"></svg>
  <script>
    const svg = d3.select("#usmap");
    const width = svg.attr("width");
    const height = svg.attr("height");
    const margin = { top: 10, right: 10, bottom: 10, left: 10 };
    const mapWidth = width - margin.left - margin.right;
    const mapHeight = height - margin.top - margin.bottom;
    const map = svg.append("g")
      .attr("transform", `translate(${margin.left}, ${margin.top})`);


    const requestData = async function () {
      const fortuneData = await d3.csv('./data/Fortune_1000.csv');
      console.log(fortuneData);
      const costOfLiving = await d3.csv('./data/cost-of-living-2018.csv');
      console.log(costOfLiving);

      // filtered the data by only returning the companies where the sector is listed as Technology
      const filteredFD = fortuneData.filter((d) => { return d.sector === "Technology"; })
      console.log(filteredFD);

      const levelsFyi = await d3.csv('./data/Levels_Fyi_Salary_Data.csv');
      console.log(levelsFyi);


      const usMap = await d3.json("./data/us.json");
      console.log(usMap);

      const cities = await d3.json("./data/cities.json");
      

      // state object stuff
      var states = topojson.feature(usMap, usMap.objects.states);
      var statesMesh = topojson.mesh(usMap, usMap.objects.states);
      var projection = d3.geoAlbersUsa().fitSize([mapWidth, mapHeight], states);
      var path = d3.geoPath().projection(projection);



      // shade in the states
      map.selectAll("path").data(states.features)
        .join("path")
        .attr("class", "state")
        .attr("note", d => d.id)
        .attr("d", path);


      // draw the borders
      map.append("path").datum(statesMesh)
        .attr("class", "border")
        .attr("d", path);

      // changing fortune 1000 dataset to become a map with key: company name and value: all other attributes
      var fortune = d3.index(filteredFD, d => d.company);
      console.log(fortune);

      // filtering levelsFyi dataset to only contain companies that are in the fortune 1000 dataset and have the same city name
      // this results in duplicates in the dataset -- entries will have the same company name and be in the same city, but each entry will be a different salary
      let levelsFyiFiltered = levelsFyi.filter( function (d, i) {
        d.citySplit = d.location.split(",");
        let fortunekey = d.company;
        let companyKey = fortune.get(fortunekey);
        return ((fortune.has(fortunekey)) && (d.citySplit[0] === companyKey.city) )
      });
      console.log(levelsFyiFiltered); 

      // getting unique cities from levelsFyi data 
      let duplicateCities = [];
      fortune.forEach( d => {
       duplicateCities.push(d.city);
      })

      let uniqueCities = duplicateCities.filter((city, i, ar) => ar.indexOf(city) === i);
      console.log(duplicateCities);
      console.log(uniqueCities);


      // make the cities data a map with key: city, value: lat/long
      var filteredCities = cities.filter( function(d) {
        return uniqueCities.includes(d.city);
      })
      console.log(filteredCities); // not all cities in the company dataset are included in the lat/long dataset


      // adding cities that don't have longitude and latitude
      let allCities = [];
      filteredCities.forEach( (d,i) => {
        allCities.push(d.city);
      })
      console.log(allCities);

      var missingCities = [];
      uniqueCities.forEach( (d,i) => {
        if (!allCities.includes(d)) {
          missingCities.push(d);
        }
      })
      console.log(missingCities);

      
      missingCities.forEach(d => {
        //filteredCities.d = d;
      })
      console.log(filteredCities);

      // get the latitude and longitutde positions for the city locations of companies
      filteredCities.forEach(d => {
        d.Position = projection([d.longitude, d.latitude]);
        // console.log(d.Position);
      })
      
      var companies = new Array();
      var newDict = {};
      // created new column companies that contains array of all companies located in that city
      filteredCities.forEach((b, i) => {
        fortune.forEach((d, i) => {
          if (d.city === b['city']) {
            companies.push(d['company']);
          }
        })
        newDict[b['city']] = companies;
        b.cityAndSalary = newDict;
        newDict = {};
        companies = [];

      })

      // plot the cities with longitude and latitude
      map.selectAll("circle.company")
         .data(filteredCities)
         .join("circle")
         .attr("class", "company")
         .attr('cx', d => d.Position[0])
         .attr('cy', d => d.Position[1])
         .style("fill", 'black')
         .attr('r', 5);



    }
    requestData();


  </script>
</body>

</html>